**********
Full Story
**********

Like I mentioned in the Github README, this project was really created to make the user experience for my friends
connecting to my home wifi as painless as possible, while at the same time making the authentication mechanism
ephemeral. So how did this whole thing go down?

Changing a password programmatically
####################################

The first thing I knew I wanted to do was automate the process of changing the password on my wifi network. When I
manually change the password, it is through a web interface on my home network, so I figured I would have to mimic
that via some kind of script. I like Python, and the requests module is really easy to use, so I figured it would
probably be what I needed. However, I didn't know what the traffic to my router looked like...

Enter Google Chrome's developer options. By viewing the developer tools (specifically the network traffic tab) while I
clicked around the interface gave me exactly what I was looking for:

* First, my router supports both the 2.4GHz band, and the 5GHz band; I wanted this project to only apply to the 2.4
  band, so I needed a way to make sure that my changes would only ever be applied to that network. In the picture
  below, you can see what data is sent to what URL when I select the 2.4GHz band

.. image:: /images/ensure_two_four_band.png

* So now I know that if I want to guarantee that my changes only ever affect the 2.4GHz band, I just need to start off
  by POSTing a JSON object that looks like the form data above to my router
* The same approach was taken to figure out how to actually change my password. Below is a screenshot of the network
  traffic tab output when I manually changed my wifi password

.. image:: /images/change_password.png

* The URL is different, and the JSON has a few more key/value pairs, but this is another really easy POST

Cool, so now I've figured out what I have to send to my router in order to change the password, but how did I do it?

* :literal:`change_pass.py` reads a config file containing my router credentials, and the IP address it can be reached
  at, and uses those to POST data with Python's requests module. It first makes sure I am only changing the 2.4GHz
  band, then it changes the password to a randomly generated string. It writes that string back to the config file for
  later use.

.. note:: It also writes that data to a file that the Raspberry Pi uses for connecting to wifi - my setup involves me
          changing the password to the network that I am currently connected to, which means I have to reconnect before
          doing anything else. But more on that later.

Generating a QR code
####################

Now I had a script that could change my password, which is cool, but not all that useful unless I wanted to go
digging around in config files on my Raspberry Pi every time it changed. My solution here was to generate a QR code
that contained the authentication data (I'm purposely being vague here and not saying "password", is this
foreshadowing? Stay tuned.)

* It turns out generating a QR code in Python is really easy, and I happened to have some code lying around that was
  already working. `https://chart.googleapis.com/chart? <https://chart.googleapis.com/chart?>`_ allows you to send
  Google data and get back a QR code representing that data
* :literal:`generate_qr.py` does that and writes the resulting QR code png file to disk

I'm done right?!? I can change my password, and I can make a png file of that QR code - let's call it a day.

.. warning:: Wrong

SSH and other Rasbian configuration
###################################

In order to administer the Pi remotely, display things to the LCD screen, connect to wifi on boot, run Python3.6 code,
and a few other things, I needed to install some packages and change some config files. I should note here that setting
up SSH on the Pi was the first thing I did because I am running the whole thing headless. Anyways, here's what I did:

* I chose Raspbian Stretch Lite as my version of Raspbian to build this project on
* Made a blank file called :literal:`SSH` and copied it into the boot partition so that I can remotely administer
  the Pi
* Plugged the Pi into power, and an ethernet cable, and SSHed in with the default :literal:`pi@<ip_address>`. The
  default password is "raspbian" (no quotes)
* I always then change the default passwords to something else, by running :literal:`sudo passwd root` and
  :literal:`sudo passwd pi`
* Ran :literal:`sudo apt-get update && sudo apt-get upgrade` to make sure that everything is up-to-date
* Ran :literal:`sudo apt-get install git` so I could use git
* Ran :literal:`sudo apt-get install fbi` so you I could display to my LCD screen
* Ran :literal:`sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev`
  for a bunch of packages that I needed for Python
* Ran :literal:`sudo wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz` to pull down the Python 3.6.5 release
* Ran :literal:`tar xf Python-3.6.5.tar.xz` to unzip it
* Ran :literal:`cd Python-3.6.5`
* Ran :literal:`sudo ./configure`
* Ran :literal:`sudo make`
* Ran :literal:`sudo make install`
* Ran :literal:`sudo pip3 install --upgrade pip`
* Ran :literal:`sudo nano /etc/network/interfaces` and set up my interfaces like below

::

  auto lo
  iface lo inet loopback

  auto eth0
  allow-hotplug eth0
  iface eth0 inet dhcp

  auto <interface>
  allow-hotplug wlan0
  iface <interface> inet dhcp
  wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf

  iface <wifi_nickname> inet dhcp

* Run :literal:`sudo nano /etc/wpa_supplicant/wpa_supplicant.conf` and set up my wifi connections like below

::

  ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
  update_config=1

  network={
    id_str="<wifi_nickname>"
    ssid="<SSID>"
    psk="<password>"
    proto=RSN
    key_mgmt=WPA-PSK
    pairwise=CCMP
  }

Raspberry Pi and drivers...a story of pain and suffering
########################################################

The whole point of this project was to make something that I could leave in the corner of my living room, and direct
people to when they arrive so that they can get on my network. Raspberry Pis are pretty much the gold standard for that
kind of thing, except for when the drivers you need for your other hardware is poorly maintained and/or poorly
documented. I'm using Raspbian Stretch Lite with an `OURLINK AC600 <https://www.amazon.com/gp/product/B011T5IF06/>`_
wifi dongle and a `LANDZO 3.5 inch LCD screen <https://www.amazon.com/gp/product/B01IGBDT02/>`_. Lucky for me, this
means that nothing works out of the box, and I get to learn (by trial and error - and a lot of re-imaging my Pi)

The Wifi Dongle
***************

First thing's first; I need internet. I like the OURLINK AC600 because it supports both 2.4 and 5 GHz bands, and it
allows me to use SoftAP mode (presenting as an access point). That isn't really all that helpful for this project, but
I had a bunch lying around because I bought a bunch for other projects that will need SoftAP mode. The OURLINK AC600
uses the Realtek rtl8812au driver, so to Google I went. Fortunately for me, a few folks created
`this repo <https://github.com/gnab/rtl8812au/>`_ which includes everything needed to set up the rtl8812au on Linux.
However, their use-case is not configured to work as-is on the Raspberry Pi, so I forked the repo
`here <https://github.com/kmanc/rtl8812au/>`_ and changed the config file so that all I really have to do is run the
installer script. So to get up and running, I:

* Ran :literal:`sudo apt-get install raspberrypi-kernel-headers` which was needed to help set up drivers
* Ran :literal:`sudo git clone https://github.com/kmanc/rtl8812au.git` to clone my repo
* Ran :literal:`cd rtl8812au`
* Ran :literal:`sudo chmod +x install.sh` so I could actually run the installer script
* Ran :literal:`sudo ./install.sh` to install the things

This got my wifi dongle working, which was a big plus. I was no longer tethered to ethernet.

The LCD Screen
**************

Now I needed to set up my LCD screen. This one...was rough. There is documentation on the website that outlines how to
get it working, but it is outdated and incorrect. Fortunately the waveshare35a drivers that the screen uses are not
uncommon, and after a lot of searching, trying, and failing I came across an
`Amazon customer review <https://www.amazon.com/gp/customer-reviews/R3CGCFPLQ232W2/>`_ that outlines the correct way
to get a screen using the waveshare35a drivers to work. I made as many of the config file changes as I could and put
them in `another repo of mine <https://github.com/kmanc/waveshare35a>`_, so that all I had to do is the following:

* Run :literal:`sudo nano /boot/config.txt` and add the following to the very end of the file. This lets my Pi
  know what drivers I want to load for my display

::

  dtparam=spi=on
  dtoverlay=ads7846,penirq=25,penirq_pull=2,xohms=150,swapxy=1,xmin=300,ymin=700,xmax=3800,ymax=3400,pmax=255
  dtoverlay=waveshare35a

* Run :literal:`sudo git clone https://github.com/kmanc/waveshare35a.git` to pull down my repo
* Run :literal:`cd waveshare35a`
* Run :literal:`sudo mv waveshare35a-overlay.dtbo /boot/overlays/` to put the driver files in the right place
* Run :literal:`sudo mv LCD-show/ ..` same as above
* Run :literal:`cd ..`
* Run :literal:`rm -rf waveshare35a/` because I don't really need it anymore
* Run :literal:`cd LCD-show/`
* Run :literal:`sudo chmod +x LCD35-show` so I can run the installer script
* Run :literal:`sudo ./LCD35-show` to run the setup script

Now my LCD screen is working too! Nice, I'm actually pretty close now.

Creating an image so that you don't have to suffer
##################################################

This section was purely optional, but I thought it was pretty cool and I had never done it before, so here it goes. It
took me a long time to set up my Pi in such a way that all the things I wanted to do could even work, and that wasn't
really the intent of this project. I so created my own Raspbian image that did as much of the unnecessary stuff as it
can. That way the amount of setup required to recreate my results is as little as possible.

* First I used Win32DiskImager to read the contents of my post-setup Raspberry Pi SD card to a .img file
   * I actually kinda thought it would be that easy, but unfortunately that reads the entire drive
     and I only wanted the part containing the OS
* I did some searching and found
  `a pretty great tutorial <http://www.aoakley.com/articles/2015-10-09-resizing-sd-images.php>`_ on how to shrink an
  existing image such that the junk (actually empty space in this case) is left off. I needed a linux machine to do it
  on, but I had an Ubuntu VM lying around that fit the bill.
* I couldn't remember when the last time I had used it was, so I started with good ol'
  :literal:`sudo apt-get update && sudo apt-get upgrade`
* Now I needed to add gparted, so I ran :literal:`sudo apt-get install gparted`
* Then I found the start sector for the partition I needed to shrink with :literal:`sudo fdisk -l <image_name>.img`
* I had to mount that partition with :literal:`sudo losetup /dev/loop0 imagename.img -o $((START#*512))`
   * I had some trouble getting this to work the way it was described in the tutorial, so I just incremented the
     number after "loop" until I didn't get an error message (ie, I tried :literal:`/dev/loop0`,
     :literal:`/dev/loop1`, :literal:`/dev/loop2`...)
* In gparted I selected the partition menu, and then "resize/move" and set the new size to be a little more than the
  minimum size
* I clicked apply all operations, and took note of the new size (and the letter that followed it, in my case, "K") -
  we'll call that NEWSIZE#
* I then ran the following 3 commands, replacing 0 with the number that I had used before (for me it was 6)
   * sudo losetup -d /dev/loop0
   * sudo losetup /dev/loop0 <image_name>.img
   * sudo fdisk /dev/loop0
* Within fdisk, I ran the following options
   * :literal:`d 2`
   * :literal:`n p 2`
   * entered the START# from before
   * :literal:`+NEWSIZE#` including the letter and plus sign!
   * :literal:`w`
* Now outside of fdisk, I ran the following commands, again using the correct number in place of 0
   * :literal:`sudo fdisk -l /dev/loop0` - taking note of the end sector
   * :literal:`sudo losetup -d /dev/loop0`
   * :literal:`truncate -s $(((END+1)*512)) <image_name>.img`

And that was it! Now I have a custom Rasbian Stretch Lite image with all the setup done for my use case. It is being
hosted `here <https://github.com/kmanc/custom_raspbian_stetch_lite/>`_ if you'd like to pull it down

Getting this repo running on the Pi
###################################

Now that my Pi was set up, it's time to grab my code and set up some project-specific things. I...

* Ran :literal:`git clone https://github.com/kmanc/wifi_qr.git` to get the project code
* Ran :literal:`cd wifi_qr`, followed by :literal:`chmod +x restart_networking.sh` and :literal:`chmod +x show_qr.sh`
  to make sure that the bash scripts are allowed to run
* Ran :literal:`pip install -r requirements.txt` to get the Python module's needed for the scripts to work
* Ran :literal:`sudo nano config.ini` and made a file that looks like this

::

  [ROUTER]
  ip = <router_ip_address>
  username = <username_to_log_in_to_router>
  password = <password_to_log_in_to_router>

  [WIFI]
  ssid = <wifi_ssid>
  password_length = <desired_wifi_password_length>

Tying it all together in cron
#############################

So I got everything working manually! Cool! now all I really had to do was set up a cron job to do things automagically.
I ran :literal:`sudo crontab -e` on my Pi and entered the following:

::

  # min hour day(of month) mon day(of week) command
  0 2 1 * * /usr/local/bin/python3 /home/pi/wifi_qr/change_pass.py >> /home/pi/cronlogs/change.log 2>&1
  1 2 1 * * /home/pi/wifi_qr/./restart_networking.sh >> /home/pi/cronlogs/network.log 2>&1
  2 2 1 * * /usr/local/bin/python3 /home/pi/wifi_qr/generate_qr.py >> /home/pi/cronlogs/generate.log 2>&1
  3 2 1 * * /home/pi/wifi_qr/./show_qr.sh >> /home/pi/cronlogs/show.log 2>&1

.. note:: I had created a "cronlogs" directory on my Pi for logging stuff just in case I ever needed to see what
          was going on

And that's it! Now my password changes at 2am on the first of every month, and my Pi shows me a QR code that represents
the new password. I had a lot of fun with this project, and I'd love to hear what you think about it!

Making the user experience clean (ie. version 2)
################################################

COMING SOON (tm) I hope
